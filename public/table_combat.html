<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Table de Combat - Judo Manager</title>

    <!-- Bootstrap 5 -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <!-- Font Awesome -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" rel="stylesheet">
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link href="table_combat.css" rel="stylesheet">
</head>

<body>
<!-- Navigation -->
<nav class="navbar navbar-expand-lg navbar-light bg-white">
    <div class="container-fluid">
        <a class="navbar-brand fw-bold text-primary" href="gestion_tatamis.html">
            <i class="fas fa-arrow-left me-2"></i><span id="tatamiName">Table de Combat</span>
        </a>
        <div class="d-flex align-items-center">
            <span class="badge bg-success me-3" id="statusIndicator">
                <i class="fas fa-circle me-1"></i>Connect√©
            </span>
        </div>


    </div>
</nav>

<!-- Main Content -->
<div class="container-fluid py-3">
    <!-- Informations du tatami -->
    <div class="tatami-info" id="tatamiInfo">
        <div class="row">
            <div class="col-md-8">
                <h6 class="mb-1"><i class="fas fa-th-large me-2"></i><span id="tatamiTitle">Tatami</span></h6>
                <p class="text-muted mb-0">Combat <span id="combatIndex">0</span> sur <span id="totalCombats">0</span></p>
            </div>
            <div class="col-md-4 text-end">
                <span class="badge bg-primary" id="confrontationScore">0 - 0</span>
            </div>
        </div>
    </div>

    <!-- Zone principale de combat -->
    <div class="combat-zone" id="combatZone">
        <div class="combat-header">
            <h5 class="mb-0">Combat en cours</h5>
        </div>

        <div class="combattants-display">
            <!-- Combattant Rouge -->
            <div class="combattant-rouge">
                <div class="combattant-nom" id="rougeNom">-</div>
                <div class="combattant-equipe" id="rougeEquipe">-</div>
                <div class="scores-display" id="rougeScores">
                    <!-- Scores dynamiques -->
                </div>
            </div>

            <!-- Timer central -->
            <div class="timer-central">
                <div class="etat-combat etat-prevu" id="etatCombat">Pr√™t</div>
                <div class="timer-display" id="timerDisplay">4:00</div>
                <!-- ‚ö†Ô∏è NOUVEAU : Contr√¥les rapides du timer -->
                <div class="timer-controls" id="timerControls">
                    <button class="btn-timer-adjust" onclick="adjustTimer(-30)" title="Retirer 30s">
                        <i class="fas fa-minus"></i> 30s
                    </button>
                    <button class="btn-timer-adjust" onclick="adjustTimer(-10)" title="Retirer 10s">
                        <i class="fas fa-minus"></i> 10s
                    </button>
                    <button class="btn-timer-adjust btn-timer-edit" onclick="showTimerEditModal()" title="Modifier">
                        <i class="fas fa-edit"></i>
                    </button>
                    <button class="btn-timer-adjust" onclick="adjustTimer(10)" title="Ajouter 10s">
                        <i class="fas fa-plus"></i> 10s
                    </button>
                    <button class="btn-timer-adjust" onclick="adjustTimer(30)" title="Ajouter 30s">
                        <i class="fas fa-plus"></i> 30s
                    </button>
                </div>

                <!-- Osaekomi -->
                <div class="osaekomi-display" id="osaekomoDisplay">
                    <div><strong>OSAEKOMI</strong></div>
                    <div class="osaekomi-timer" id="osaekomoTimer">00</div>
                    <div><small>Maintien au sol</small></div>
                </div>
            </div>

            <!-- Combattant Bleu -->
            <div class="combattant-bleu">
                <div class="combattant-nom" id="bleuNom">-</div>
                <div class="combattant-equipe" id="bleuEquipe">-</div>
                <div class="scores-display" id="bleuScores">
                    <!-- Scores dynamiques -->
                </div>
            </div>
        </div>
    </div>

    <!-- Contr√¥les principaux -->
    <div class="main-controls">
        <button class="btn btn-main btn-start" id="btnStart">
            <i class="fas fa-play me-2"></i>D√©marrer
        </button>
        <button class="btn btn-main btn-pause" id="btnPause">
            <i class="fas fa-pause me-2"></i>Pause
        </button>
        <button class="btn btn-main btn-stop" id="btnStop">
            <i class="fas fa-stop me-2"></i>Arr√™ter
        </button>
        <button class="btn btn-main btn-reset" id="btnReset">
            <i class="fas fa-undo me-2"></i>Reset
        </button>
    </div>

    <!-- Contr√¥les de score -->
    <div class="controls-section">
        <div class="controls-header">
            <h5 class="mb-0"><i class="fas fa-gamepad me-2"></i>Contr√¥les de Score</h5>
        </div>

        <div class="controls-grid">
            <!-- Contr√¥les Rouge -->
            <div class="control-section control-rouge">
                <h6><i class="fas fa-user me-2"></i>Rouge</h6>
                <div class="control-buttons">
                    <button class="btn-score btn-ippon" onclick="marquerPoint('rouge', 'ippon')">
                        <i class="fas fa-star me-1"></i>IPPON
                    </button>
                    <button class="btn-score btn-wazari" onclick="marquerPoint('rouge', 'wazari')">
                        <i class="fas fa-medal me-1"></i>WAZARI
                    </button>
                    <button class="btn-score btn-yuko" onclick="marquerPoint('rouge', 'yuko')">
                        <i class="fas fa-plus me-1"></i>YUKO
                    </button>
                    <button class="btn-score btn-shido" onclick="marquerPoint('rouge', 'shido')">
                        <i class="fas fa-exclamation me-1"></i>SHIDO Rouge
                    </button>
                </div>

                <!-- Boutons de correction -->
                <div class="correction-buttons mt-2">
                    <button class="btn btn-sm btn-outline-warning" onclick="showCorrectionModal('rouge')">
                        <i class="fas fa-undo me-1"></i>Corriger
                    </button>
                </div>
            </div>

            <!-- Contr√¥les Bleu -->
            <div class="control-section control-bleu">
                <h6><i class="fas fa-user me-2"></i>Bleu</h6>
                <div class="control-buttons">
                    <button class="btn-score btn-ippon" onclick="marquerPoint('bleu', 'ippon')">
                        <i class="fas fa-star me-1"></i>IPPON
                    </button>
                    <button class="btn-score btn-wazari" onclick="marquerPoint('bleu', 'wazari')">
                        <i class="fas fa-medal me-1"></i>WAZARI
                    </button>
                    <button class="btn-score btn-yuko" onclick="marquerPoint('bleu', 'yuko')">
                        <i class="fas fa-plus me-1"></i>YUKO
                    </button>
                    <button class="btn-score btn-shido" onclick="marquerPoint('bleu', 'shido')">
                        <i class="fas fa-exclamation me-1"></i>SHIDO Bleu
                    </button>
                </div>

                <!-- Boutons de correction -->
                <div class="correction-buttons mt-2">
                    <button class="btn btn-sm btn-outline-warning" onclick="showCorrectionModal('bleu')">
                        <i class="fas fa-undo me-1"></i>Corriger
                    </button>
                </div>
            </div>
        </div>

        <!-- Contr√¥les Osaekomi -->
        <div class="osaekomi-controls">
            <h6 class="text-center mb-3"><i class="fas fa-clock me-2"></i>Osaekomi (Maintien au sol)</h6>
            <div class="osaekomi-buttons">
                <button class="btn-osaekomi btn-osaekomi-rouge" onclick="startOsaekomi('rouge')">
                    <i class="fas fa-play me-1"></i>OSAEKOMI Rouge
                </button>
                <button class="btn-osaekomi btn-osaekomi-bleu" onclick="startOsaekomi('bleu')">
                    <i class="fas fa-play me-1"></i>OSAEKOMI Bleu
                </button>
                <button class="btn-osaekomi btn-osaekomi-stop" onclick="stopOsaekomi()">
                    <i class="fas fa-stop me-1"></i>TOKETA / STOP
                </button>
            </div>
        </div>
    </div>

    <!-- Actions de combat -->
    <div class="main-controls">
        <button class="btn btn-main btn-next" id="btnNext" style="display: none;">
            <i class="fas fa-forward me-2"></i>Combat Suivant
        </button>
    </div>

    <!-- File d'attente -->
    <div class="controls-section" id="queueSection" style="display: none;">
        <div class="controls-header">
            <h5 class="mb-0"><i class="fas fa-list me-2"></i>Prochains Combats</h5>
        </div>
        <div class="p-3">
            <div class="combat-queue" id="combatQueue">
                <!-- Queue dynamique -->
            </div>
        </div>
    </div>
</div>

<!-- Modal de Correction -->
<div class="modal fade" id="modalCorrection" tabindex="-1">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">
                    <i class="fas fa-undo me-2"></i>Correction du score
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="alert alert-warning">
                    <i class="fas fa-exclamation-triangle me-2"></i>
                    <strong>Attention :</strong> Vous allez modifier le score du combattant <span id="correctionCombattant" class="fw-bold"></span>
                </div>

                <h6 class="mb-3">Score actuel :</h6>
                <div id="scoreActuel" class="mb-3 p-2 border rounded bg-light">
                    <!-- Score actuel -->
                </div>

                <h6 class="mb-3">Actions disponibles :</h6>

                <!-- Retrait de points -->
                <div class="mb-4">
                    <h6 class="text-danger"><i class="fas fa-minus me-1"></i>Retirer des points</h6>
                    <div class="btn-group-vertical w-100" role="group">
                        <button type="button" class="btn btn-outline-danger" onclick="retirerPoint('ippon')" id="btnRetirerIppon" disabled>
                            <i class="fas fa-star me-2"></i>Retirer IPPON
                        </button>
                        <button type="button" class="btn btn-outline-danger" onclick="retirerPoint('wazari')" id="btnRetirerWazari" disabled>
                            <i class="fas fa-medal me-2"></i>Retirer 1 WAZARI
                        </button>
                        <button type="button" class="btn btn-outline-danger" onclick="retirerPoint('yuko')" id="btnRetirerYuko" disabled>
                            <i class="fas fa-plus me-2"></i>Retirer 1 YUKO
                        </button>
                        <button type="button" class="btn btn-outline-info" onclick="retirerPoint('shido')" id="btnRetirerShido" disabled>
                            <i class="fas fa-exclamation me-2"></i>Retirer 1 SHIDO
                        </button>
                    </div>
                </div>

                <!-- Conversion rapide -->
                <div class="mb-3">
                    <h6 class="text-warning"><i class="fas fa-exchange-alt me-1"></i>Conversions rapides</h6>
                    <div class="btn-group-vertical w-100" role="group">
                        <button type="button" class="btn btn-outline-warning" onclick="convertirScore('ippon-wazari')" id="btnConvertIpponWazari" disabled>
                            <i class="fas fa-arrow-right me-2"></i>IPPON ‚Üí WAZARI
                        </button>
                        <button type="button" class="btn btn-outline-warning" onclick="convertirScore('ippon-yuko')" id="btnConvertIpponYuko" disabled>
                            <i class="fas fa-arrow-right me-2"></i>IPPON ‚Üí YUKO
                        </button>
                        <button type="button" class="btn btn-outline-warning" onclick="convertirScore('wazari-yuko')" id="btnConvertWazariYuko" disabled>
                            <i class="fas fa-arrow-right me-2"></i>WAZARI ‚Üí YUKO
                        </button>
                    </div>
                </div>

                <!-- Remise √† z√©ro -->
                <div>
                    <h6 class="text-secondary"><i class="fas fa-eraser me-1"></i>Remise √† z√©ro</h6>
                    <button type="button" class="btn btn-outline-secondary w-100" onclick="razScore()">
                        <i class="fas fa-undo me-2"></i>Remettre tous les scores √† z√©ro
                    </button>
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Fermer</button>
            </div>
        </div>
    </div>
</div>

<!-- Modal Modification Timer -->
<div class="modal fade" id="modalTimer" tabindex="-1">
    <div class="modal-dialog modal-sm">
        <div class="modal-content">
            <div class="modal-header">
                <h5 class="modal-title">
                    <i class="fas fa-clock me-2"></i>Modifier le timer
                </h5>
                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
            </div>
            <div class="modal-body">
                <div class="alert alert-info">
                    <i class="fas fa-info-circle me-2"></i>
                    Ajustez la dur√©e du combat selon la cat√©gorie
                </div>

                <div class="mb-3">
                    <label class="form-label">Dur√©es pr√©d√©finies :</label>
                    <div class="d-grid gap-2">
                        <button class="btn btn-outline-primary" onclick="setTimerPreset(180)">
                            3:00 (Cadets/Cadettes)
                        </button>
                        <button class="btn btn-outline-primary" onclick="setTimerPreset(240)">
                            4:00 (Juniors)
                        </button>
                        <button class="btn btn-outline-primary" onclick="setTimerPreset(300)">
                            5:00 (Seniors)
                        </button>
                    </div>
                </div>

                <div class="mb-3">
                    <label for="timerMinutes" class="form-label">Personnalis√© :</label>
                    <div class="row g-2">
                        <div class="col-6">
                            <input type="number" id="timerMinutes" class="form-control"
                                   min="0" max="10" placeholder="Minutes" value="4">
                        </div>
                        <div class="col-6">
                            <input type="number" id="timerSeconds" class="form-control"
                                   min="0" max="59" placeholder="Secondes" value="0">
                        </div>
                    </div>
                </div>

                <div class="alert alert-warning">
                    <i class="fas fa-exclamation-triangle me-2"></i>
                    <strong>Attention :</strong> Cette modification est imm√©diate
                </div>
            </div>
            <div class="modal-footer">
                <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Annuler</button>
                <button type="button" class="btn btn-primary" onclick="applyCustomTimer()">
                    <i class="fas fa-check me-2"></i>Appliquer
                </button>
            </div>
        </div>
    </div>
</div>

<!-- Victory Overlay -->
<div class="victory-overlay" id="victoryOverlay">
    <div class="victory-content">
        <h1><i class="fas fa-trophy"></i></h1>
        <h2 id="victoryWinner">VICTOIRE!</h2>
        <p id="victoryMethod">Par Ippon</p>
        <button class="btn btn-primary btn-lg mt-3" onclick="hideVictory()">
            Continuer
        </button>
    </div>
</div>
<div class="fin-rencontre-overlay" id="finRencontreOverlay">
    <div class="fin-rencontre-content">
        <div class="fin-rencontre-icon">
            <i class="fas fa-flag-checkered"></i>
        </div>
        <h1 class="fin-rencontre-title">FIN DE LA RENCONTRE</h1>
        <p class="fin-rencontre-subtitle">Tous les combats sont termin√©s</p>

        <div class="score-final-container">
            <div class="score-final-label">Score Final</div>
            <div class="score-final-value" id="scoreFinalDisplay">0 - 0</div>
        </div>

        <div class="fin-rencontre-actions">
            <button class="btn btn-outline-light btn-lg me-3" onclick="hideFinRencontre()">
                <i class="fas fa-times me-2"></i>Fermer
            </button>
            <button class="btn btn-success btn-lg" onclick="retourGestionTatamis()">
                <i class="fas fa-arrow-left me-2"></i>Retour Tatamis
            </button>
        </div>
    </div>
</div>


<!-- Loading Overlay -->
<div class="loading-overlay" id="loadingOverlay" style="display: none;">
    <div class="loading-spinner"></div>
</div>

<!-- Scripts -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>


<script>
    // =======================================
    // TABLE DE COMBAT - SCRIPT COMPLET
    // Application Judo Manager
    // =======================================

    // Variables globales
    const API_URL = '/api';
    let eventSource = null;
    let tatamiId = null;
    let combat = null;
    let tatami = null;
    let timer = 240; // Timer local pour affichage
    let timerInterval = null;
    let osaekomiTimer = 0;
    let osaekomiInterval = null;
    let osaekomiState = { active: false, cote: null };
    let correctionCote = null;
    let CONFIG = null;
    let reconnectAttempts = 0;
    const MAX_RECONNECT_ATTEMPTS = 5;

    // =======================================
    // INITIALISATION
    // =======================================

    document.addEventListener('DOMContentLoaded', async function() {
        // R√©cup√©rer l'ID du tatami depuis l'URL
        const urlParams = new URLSearchParams(window.location.search);
        tatamiId = parseInt(urlParams.get('tatami'));

        if (!tatamiId) {
            showNotification('ID de tatami manquant', 'danger');
            return;
        }
        await loadConfig();
        loadData();
        connectSSE(tatamiId);
        setupEventListeners();

    });

    // ========================================
    // CONNEXION SSE AU TATAMI
    // ========================================


    function connectSSE(tatamiId) {
        if (eventSource) {
            eventSource.close();
        }

        eventSource = new EventSource(`${API_URL}/tatamis/${tatamiId}/events`);

        eventSource.addEventListener('init', (event) => {
            const data = JSON.parse(event.data);
            console.log('üì° √âtat initial re√ßu:', data);

            if (data.tatami) {
                tatami = data.tatami;
                //updateTatamiInfo(data.tatami);
            }
            if (data.combat) {
                combat = data.combat;
                updateCombatDisplay();
            }

            reconnectAttempts = 0;
            updateConnectionStatus(true);
        });

        eventSource.addEventListener('tatami_update', (event) => {
            const data = JSON.parse(event.data);
            console.log('üîÑ Mise √† jour tatami:', data);

            if (data.tatami) {
                tatami = data.tatami;
                updateTatamiInfo();
            }
            if (data.combatActuel) {
                combat = data.combatActuel;
                updateCombatDisplay();
                updateQueue();
            }
        });

        eventSource.addEventListener('combat_update', (event) => {
            const data = JSON.parse(event.data);
            console.log('‚öîÔ∏è Mise √† jour combat:', data);

            if (data.combat) {
                combat = data.combat;
                updateCombatDisplay();
            }
        });

        eventSource.onerror = (error) => {
            console.error('‚ùå Erreur SSE:', error);
            updateConnectionStatus(false);

            if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
                reconnectAttempts++;
                const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 30000);
                console.log(`üîÑ Reconnexion dans ${delay / 1000}s...`);
                setTimeout(() => connectSSE(tatamiId), delay);
            }
        };
    }

    function updateConnectionStatus(connected) {
        const indicator = document.getElementById('statusIndicator');
        if (!indicator) return;

        if (connected) {
            indicator.className = 'badge bg-success me-3';
            indicator.innerHTML = '<i class="fas fa-circle me-1"></i>Connect√©';
        } else {
            indicator.className = 'badge bg-danger me-3';
            indicator.innerHTML = '<i class="fas fa-circle me-1"></i>D√©connect√©';
        }
    }


    // =======================================
    // CHARGEMENT DES DONN√âES
    // =======================================

    async function loadConfig() {
        try {
            CONFIG = await fetch('/api/config').then(r => r.json());
            console.log('‚úÖ Config charg√©e:', CONFIG);
            timer = CONFIG.combat.dureeParDefaut || 240;
        } catch (error) {
            console.error('‚ùå Erreur chargement config:', error);
            CONFIG = {
                combat: {
                    dureeParDefaut: 240,
                    osaekomi: {
                        yuko: 10,
                        wazari: 15,
                        ippon: 20
                    },
                    thresholds: {
                        wazariForIppon: 2,
                        shidoForDefeat: 3
                    },
                    timerSyncInterval: 10
                },
                display: {
                    notificationDuration: 3000,
                    maxCombatsQueue: 5,
                    timerWarningThreshold: 30,
                    timerDangerThreshold: 10
                }
            };
        }
    }

    async function loadData() {
        showLoading(true);
        try {
            // Utiliser les endpoints du contr√¥leur
            const [tatamiResponse, combatResponse] = await Promise.all([
                fetch(`/api/tatamis/${tatamiId}`),
                fetch(`/api/tatamis/${tatamiId}/combat-actuel`)
            ]);

            if (tatamiResponse.ok) {
                tatami = await tatamiResponse.json();
            } else {
                throw new Error('Tatami non trouv√©');
            }

            if (combatResponse.ok) {
                const combatData = await combatResponse.json();
                combat = combatData; // Le service enrichit d√©j√† le combat
            }

            updateTatamiInfo();
            updateCombatDisplay();
            updateQueue();
        } catch (error) {
            console.error('Erreur chargement:', error);
            showNotification('Erreur de chargement', 'danger');
        } finally {
            showLoading(false);
        }
    }

    // =======================================
    // MISE √Ä JOUR DE L'INTERFACE
    // =======================================

    function updateTatamiInfo() {
        if (!tatami) return;

        document.getElementById('tatamiName').textContent = `Table - ${tatami.nom}`;
        document.getElementById('tatamiTitle').textContent = tatami.nom;

        const currentIndex = tatami.indexCombatActuel || 0;
        const totalCombats = tatami.combatsIds ? tatami.combatsIds.length : 0;

        document.getElementById('combatIndex').textContent = currentIndex + 1;
        document.getElementById('totalCombats').textContent = totalCombats;

        // Score de confrontation (calcul√© par le service)
        const score = tatami.scoreConfrontation || { rouge: 0, bleu: 0 };
        document.getElementById('confrontationScore').textContent = `${score.rouge} - ${score.bleu}`;
    }

    // ‚ö†Ô∏è NOUVELLE FONCTION : Recharger uniquement le tatami pour le score
    async function reloadTatamiScore() {
        try {
            const response = await fetch(`/api/tatamis/${tatamiId}`);
            if (response.ok) {
                tatami = await response.json();
                updateTatamiInfo();
            }
        } catch (error) {
            console.error('Erreur rechargement score:', error);
        }
    }

    function updateCombatDisplay() {
        console.log('üü¢ [DEBUG] updateCombatDisplay() appel√©');
        console.log('üü¢ [DEBUG] combat:', combat);
        if (!combat) {
            showNoCombat();
            return;
        }
        console.log('üü¢ [DEBUG] Affichage du combat ID:', combat.id);
        console.log('üü¢ [DEBUG] Rouge:', combat.rouge?.nom);
        console.log('üü¢ [DEBUG] Bleu:', combat.bleu?.nom);

        // Utiliser les donn√©es enrichies par combatService
        document.getElementById('rougeNom').textContent = combat.rouge?.nom || 'Rouge';
        document.getElementById('bleuNom').textContent = combat.bleu?.nom || 'Bleu';
        document.getElementById('rougeEquipe').textContent = combat.rouge?.equipe || '√âquipe';
        document.getElementById('bleuEquipe').textContent = combat.bleu?.equipe || '√âquipe';


        const chronoActif = timerInterval !== null;
        if (!chronoActif) {
            timer = combat.tempsEcoule || combat.temps_ecoule || combat.dureeCombat || CONFIG?.combat?.dureeParDefaut || 240;
        }
        updateScoreDisplay();
        updateTimerDisplay();
        updateEtatCombat();
    }

    function updateScoreDisplay() {
        if (!combat) return;

        // Affichage rouge
        let rougeHtml = '';
        const ipponRouge = combat.rouge?.ippon || combat.rouge_ippon || combat.ipponRouge || false;

        if (ipponRouge) {
            rougeHtml += '<div class="score-badge score-ippon">IPPON</div>';
        }
            const wazariRouge = combat.rouge?.wazari || combat.rouge_wazari || 0;
            const yukoRouge = combat.rouge?.yuko || combat.rouge_yuko || 0;

            if (wazariRouge > 0) {
                rougeHtml += `<div class="score-badge score-rouge">${wazariRouge} WAZARI</div>`;
            }
            if (yukoRouge > 0) {
                rougeHtml += `<div class="score-badge score-rouge">${yukoRouge} YUKO</div>`;
            }


        const shidoRouge = combat.rouge?.shido || combat.rouge_shido || 0;
        if (shidoRouge > 0) {
            rougeHtml += `<div class="score-badge" style="background: #757575; color: white;">${shidoRouge} SHIDO</div>`;
        }
        document.getElementById('rougeScores').innerHTML = rougeHtml;

        // Affichage bleu
        let bleuHtml = '';
        if (combat.bleu?.ippon || combat.bleu_ippon) {
            bleuHtml += '<div class="score-badge score-ippon">IPPON</div>';
        } else {
            const wazariBleu = combat.bleu?.wazari || combat.bleu_wazari || 0;
            const yukoBleu = combat.bleu?.yuko || combat.bleu_yuko || 0;

            if (wazariBleu > 0) {
                bleuHtml += `<div class="score-badge score-bleu">${wazariBleu} WAZARI</div>`;
            }
            if (yukoBleu > 0) {
                bleuHtml += `<div class="score-badge score-bleu">${yukoBleu} YUKO</div>`;
            }
        }

        const shidoBleu = combat.bleu?.shido || combat.bleu_shido || 0;
        if (shidoBleu > 0) {
            bleuHtml += `<div class="score-badge" style="background: #757575; color: white;">${shidoBleu} SHIDO</div>`;
        }
        document.getElementById('bleuScores').innerHTML = bleuHtml;
    }

    function updateTimerDisplay() {
        const minutes = Math.floor(timer / 60);
        const seconds = timer % 60;
        const timeStr = `${minutes}:${seconds.toString().padStart(2, '0')}`;

        const timerEl = document.getElementById('timerDisplay');
        timerEl.textContent = timeStr;

        timerEl.className = 'timer-display';
        const dangerThreshold = CONFIG?.display?.timerDangerThreshold || 10;
        const warningThreshold = CONFIG?.display?.timerWarningThreshold || 30;

        if (timer <= dangerThreshold) {
            timerEl.classList.add('danger');
        } else if (timer <= warningThreshold) {
            timerEl.classList.add('warning');
        }
    }

    function updateEtatCombat() {
        if (!combat) return;

        const etatEl = document.getElementById('etatCombat');
        const etat = combat.etat || 'pr√©vu';

        etatEl.className = 'etat-combat';
        etatEl.textContent = etat.charAt(0).toUpperCase() + etat.slice(1);

        switch (etat) {
            case 'pr√©vu':
                etatEl.classList.add('etat-prevu');
                break;
            case 'en cours':
                etatEl.classList.add('etat-en-cours');
                break;
            case 'pause':
                etatEl.classList.add('etat-pause');
                break;
            case 'termin√©':
                etatEl.classList.add('etat-termine');
                showCombatTermine();
                break;
        }
        updateTimerControlsVisibility();
    }

    function showNoCombat() {
        document.getElementById('rougeNom').textContent = 'Aucun';
        document.getElementById('rougeEquipe').textContent = 'combat';
        document.getElementById('bleuNom').textContent = 'assign√©';
        document.getElementById('bleuEquipe').textContent = '';
        document.getElementById('rougeScores').innerHTML = '';
        document.getElementById('bleuScores').innerHTML = '';
        document.getElementById('etatCombat').textContent = 'En attente';
        document.getElementById('timerDisplay').textContent = '0:00';
    }

    // =======================================
    // ACTIONS DE COMBAT
    // =======================================

    async function startCombat() {
        if (!combat) return;

        try {
            const response = await fetch(`/api/combats/${combat.id}`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ etat: 'en cours' })
            });

            if (response.ok) {
                const updatedCombat = await response.json();
                combat = updatedCombat;
                updateCombatDisplay();
                startTimerDisplay();
                showNotification('Combat d√©marr√©', 'success');
            } else {
                const error = await response.json();
                showNotification(error.error || 'Erreur lors du d√©marrage', 'danger');
            }
        } catch (error) {
            showNotification('Erreur de connexion', 'danger');
        }
    }

    async function pauseCombat() {
        if (!combat) return;

        try {
            const response = await fetch(`/api/combats/${combat.id}`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    etat: 'pause',
                    temps_ecoule: timer
                })
            });

            if (response.ok) {
                const updatedCombat = await response.json();
                const savedTimer = timer;
                combat = updatedCombat;
                timer = savedTimer;
                updateEtatCombat();
                stopTimerDisplay();
                showNotification('Combat en pause', 'warning');
            }
        } catch (error) {
            showNotification('Erreur', 'danger');
        }
    }

    async function stopCombat() {
        if (!combat) return;
        if (!confirm('Arr√™ter d√©finitivement ce combat ?')) return;

        try {
            const response = await fetch(`/api/combats/${combat.id}`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    etat: 'termin√©',
                    temps_ecoule: 0,
                    date_fin: new Date().toISOString(),
                    raison_fin: 'arret_manuel'
                })
            });

            if (response.ok) {
                combat = await response.json();
                updateCombatDisplay();
                stopTimerDisplay();
                stopOsaekomi();

                if (combat.vainqueur) {
                    showVictory(combat.vainqueur, combat.raisonFin);
                }

                showNotification('Combat arr√™t√©', 'info');
            }
        } catch (error) {
            showNotification('Erreur', 'danger');
        }
    }

    async function resetCombat() {
        if (!combat) return;
        if (!confirm('Remettre √† z√©ro ce combat ? Tous les scores seront perdus.')) return;

        try {
            const response = await fetch(`/api/combats/${combat.id}`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    action: 'reset'
                })
            });

            if (response.ok) {
                const resetCombat = await response.json();
                combat = resetCombat;
                timer = combat.timer || 240;

                updateCombatDisplay();
                stopTimerDisplay();
                cleanupOsaekomoDisplay();

                document.getElementById('btnNext').style.display = 'none';
                hideVictory();

                showNotification('Combat remis √† z√©ro', 'info');
            } else {
                const error = await response.json();
                showNotification(error.error || 'Erreur de remise √† z√©ro', 'danger');
            }
        } catch (error) {
            showNotification('Erreur de connexion', 'danger');
        }
    }

    async function combatSuivant() {
        console.log('üîµ [DEBUG] D√©but combatSuivant()');
        console.log('üîµ [DEBUG] tatami actuel:', tatami);
        console.log('üîµ [DEBUG] combat actuel:', combat);

        if (!tatami) {
            console.error('‚ùå [DEBUG] Pas de tatami !');
            return;
        }

        try {
            console.log('üîµ [DEBUG] Envoi requ√™te POST /api/tatamis/' + tatamiId + '/suivant');

            const response = await fetch(`/api/tatamis/${tatamiId}/suivant`, {
                method: 'POST'
            });

            console.log('üîµ [DEBUG] Response status:', response.status);
            console.log('üîµ [DEBUG] Response ok:', response.ok);

            if (response.ok) {
                const result = await response.json();
                console.log('‚úÖ [DEBUG] R√©sultat re√ßu:', result);

                // Mettre √† jour les variables globales
                const ancienCombat = combat?.id;
                tatami = result.tatami;
                combat = result.combatActuel;

                console.log('üîµ [DEBUG] Ancien combat ID:', ancienCombat);
                console.log('üîµ [DEBUG] Nouveau combat:', combat);
                console.log('üîµ [DEBUG] Nouveau tatami:', tatami);

                // Mettre √† jour l'affichage
                updateTatamiInfo();
                updateCombatDisplay();
                updateQueue();

                // R√©initialiser le timer
                timer = combat?.temps_ecoule || CONFIG?.combat?.dureeParDefaut || 240;
                console.log('üîµ [DEBUG] Timer r√©initialis√© √†:', timer);

                // Cacher le bouton suivant et le popup de victoire
                document.getElementById('btnNext').style.display = 'none';
                hideVictory();

                showNotification('Combat suivant', 'success');
            } else {
                const error = await response.json();
                console.error('‚ùå [DEBUG] Erreur backend:', error);

                if (error.error && error.error.includes('dernier combat')) {
                    showFinRencontrePopup();
                } else {
                    showNotification(error.error || 'Pas de combat suivant', 'warning');
                }
            }
        } catch (error) {
            console.error('‚ùå [DEBUG] Erreur catch:', error);
            showNotification('Erreur', 'danger');
        }
    }

    // =======================================
    // MARQUAGE DES POINTS
    // =======================================

    function getScoreUpdate(cote, type) {
        const updates = {};

        switch (type) {
            case 'ippon':
                updates[`${cote}_ippon`] = 1;
                break;
            case 'wazari':
                updates[`${cote}_wazari`] = (combat[`${cote}_wazari`] || 0) + 1;
                break;
            case 'yuko':
                updates[`${cote}_yuko`] = (combat[`${cote}_yuko`] || 0) + 1;
                break;
            case 'shido':
                updates[`${cote}_shido`] = (combat[`${cote}_shido`] || 0) + 1;
                break;
        }

        return updates;
    }

    async function marquerPoint(cote, type) {
        if (!combat || combat.etat === 'termin√©') return;

        try {
            const response = await fetch(`/api/combats/${combat.id}`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(getScoreUpdate(cote, type))
            });

            if (response.ok) {
                const updatedCombat = await response.json();
                // ‚ö†Ô∏è AJOUTER CE LOG POUR DEBUG
                console.log('üéØ Combat re√ßu du backend:', updatedCombat);
                console.log('üî¥ Rouge:', updatedCombat.rouge);
                console.log('üîµ Bleu:', updatedCombat.bleu);
                const timerLocal = timer;
                combat = updatedCombat;
                timer = timerLocal;
                updateScoreDisplay();

                if (combat.etat === 'termin√©') {
                    stopTimerDisplay();
                    stopOsaekomi();
                    showCombatTermine();
                    showNotification(`${type.toUpperCase()} marqu√© pour ${cote}`, 'success');


                    setTimeout(() => {
                        reloadTatamiScore();
                    }, 500);

                    if (combat.vainqueur) {
                        const vainqueurNom = combat.vainqueur === 'rouge' ?
                            combat.rouge.nom : combat.bleu.nom;
                        showVictory(vainqueurNom, combat.raisonFin);
                    }
                }

                showNotification(`${type.toUpperCase()} ${cote}`, 'success');
            } else {
                const error = await response.json();
                showNotification(error.error || 'Erreur lors du marquage', 'danger');
            }
        } catch (error) {
            showNotification('Erreur de connexion', 'danger');
        }
    }

    // =======================================
    // GESTION OSAEKOMI
    // =======================================

    async function startOsaekomi(cote) {
        if (!combat || combat.etat !== 'en cours') return;

        // Arr√™ter un osaekomi en cours
        if (osaekomiState.active) {
            await stopOsaekomi();
        }

        try {
            const response = await fetch(`/api/combats/${combat.id}`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    osaekomi_actif: true,
                    osaekomi_cote: cote,
                    osaekomi_debut: new Date().toISOString()
                })
            });

            if (response.ok) {
                // D√©marrer imm√©diatement l'affichage local
                osaekomiState = { active: true, cote: cote };
                osaekomiTimer = 0;

                // Afficher le panneau osaekomi imm√©diatement
                const osaekomoDisplay = document.getElementById('osaekomoDisplay');
                osaekomoDisplay.classList.add('active');
                document.getElementById('osaekomoTimer').textContent = '00';

                // Sauvegarder l'√©tat initial des scores pour la simulation
                const initialState = JSON.parse(JSON.stringify(combat));

                // D√©marrer le timer d'affichage avec simulation temps r√©el
                osaekomiInterval = setInterval(async () => {
                    osaekomiTimer++;
                    document.getElementById('osaekomoTimer').textContent =
                        osaekomiTimer.toString().padStart(2, '0');

                    // NOUVEAU : Simuler l'affichage des points en temps r√©el
                    await simulerPointsOsaekomi(cote, osaekomiTimer, initialState);

                    if (osaekomiTimer % 2 === 0) {

                    }

                    // Auto-arr√™t √† 20 secondes (seuil Ippon)
                    const seuilIppon = CONFIG?.combat?.osaekomi?.ippon || 20;
                    if (osaekomiTimer >= seuilIppon) {
                        stopOsaekomi();
                    }
                }, 1000);

                showNotification(`OSAEKOMI ${cote.toUpperCase()}`, 'warning');
            } else {
                const error = await response.json();
                showNotification(error.error || 'Erreur osaekomi', 'danger');
            }
        } catch (error) {
            showNotification('Erreur de connexion', 'danger');
            cleanupOsaekomoDisplay();
        }
    }

    async function stopOsaekomi() {
        // ‚ö†Ô∏è NE PAS v√©rifier osaekomiState.active car √ßa peut √™tre d√©synchronis√© !
        // √Ä la place, v√©rifier si un osaekomi est actif dans le combat backend

        const dureeOsaekomi = osaekomiTimer;
        const coteOsaekomi = osaekomiState.cote;

        // Arr√™ter le timer local imm√©diatement
        if (osaekomiInterval) {
            clearInterval(osaekomiInterval);
            osaekomiInterval = null;
        }

        try {
            const response = await fetch(`/api/combats/${combat.id}`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    action: 'stop_osaekomi',
                    duree: dureeOsaekomi
                })
            });

            if (response.ok) {
                const result = await response.json();

                // ‚úÖ D'ABORD : Mettre √† jour le combat avec les VRAIES donn√©es du backend
                if (result.combat) {
                    combat = result.combat;
                }

                // ‚úÖ ENSUITE : Nettoyer l'affichage osaekomi
                cleanupOsaekomoDisplay();

                // Afficher le r√©sum√© final
                if (dureeOsaekomi > 0) {
                    const message = result.pointsMarques && result.pointsMarques.length > 0 ?
                        `OSAEKOMI termin√© (${dureeOsaekomi}s): ${result.pointsMarques.join(', ').toUpperCase()}` :
                        `TOKETA apr√®s ${dureeOsaekomi}s`;

                    showNotification(message, 'info');
                }

                // V√©rifier si le combat est termin√©
                if (result.finCombat && combat.etat === 'termin√©') {
                    stopTimerDisplay();
                    showCombatTermine();

                    setTimeout(() => {
                        reloadTatamiScore();
                    }, 500);

                    if (combat.vainqueur) {
                        const vainqueurNom = combat.vainqueur === 'rouge' ?
                            combat.rouge.nom : combat.bleu.nom;
                        showVictory(vainqueurNom, combat.raisonFin || 'osaekomi_ippon');
                    }
                }
            } else {
                const error = await response.json();
                console.error('Erreur stop osaekomi:', error);
                showNotification(error.error || 'Erreur arr√™t osaekomi', 'danger');

                // En cas d'erreur, nettoyer quand m√™me
                cleanupOsaekomoDisplay();
            }
        } catch (error) {
            console.error('Erreur stop osaekomi:', error);
            showNotification('Erreur de connexion', 'danger');

            // En cas d'erreur, nettoyer quand m√™me
            cleanupOsaekomoDisplay();
        }
    }

    function cleanupOsaekomoDisplay() {
        // Arr√™ter le timer d'affichage
        if (osaekomiInterval) {
            clearInterval(osaekomiInterval);
            osaekomiInterval = null;
        }

        // Cacher l'affichage
        const osaekomoDisplay = document.getElementById('osaekomoDisplay');
        if (osaekomoDisplay) {
            osaekomoDisplay.classList.remove('active');
        }

        // Reset des variables
        osaekomiTimer = 0;
        osaekomiState = { active: false, cote: null };

        // Remettre l'affichage des scores √† jour avec les vraies donn√©es
        //updateScoreDisplay();



    }

    async function simulerPointsOsaekomi(cote, duree, initialState) {
        const seuils = {
            yuko: CONFIG?.combat?.osaekomi?.yuko || 10,
            wazari: CONFIG?.combat?.osaekomi?.wazari || 15,
            ippon: CONFIG?.combat?.osaekomi?.ippon || 20
        };

        const estNouveauSeuil = (duree === seuils.yuko) || (duree === seuils.wazari) || (duree === seuils.ippon);
        if (!estNouveauSeuil) return;

        // ‚úÖ SIMULATION VISUELLE
        const combatSimule = JSON.parse(JSON.stringify(combat));

        if (duree === seuils.ippon) {
            const wazariActuel = combatSimule[`${cote}_wazari`] || 0;
            if (wazariActuel > 0) {
                combatSimule[`${cote}_wazari`] = wazariActuel - 1;
                combatSimule[cote].wazari = wazariActuel - 1;
            }
            combatSimule[`${cote}_ippon`] = 1;
            combatSimule[cote].ippon = true;
            showNotification(`OSAEKOMI: IPPON!`, 'success');

        } else if (duree === seuils.wazari) {
            const wazariActuel = combatSimule[`${cote}_wazari`] || 0;
            const yukoActuel = combatSimule[`${cote}_yuko`] || 0;

            combatSimule[`${cote}_wazari`] = wazariActuel + 1;
            combatSimule[cote].wazari = wazariActuel + 1;
            combatSimule[`${cote}_yuko`] = yukoActuel;
            combatSimule[cote].yuko = yukoActuel;

            showNotification(`OSAEKOMI: +1 WAZARI!`, 'success');

            if (wazariActuel + 1 >= 2) {
                showNotification(`DOUBLE WAZARI - ${cote.toUpperCase()} GAGNE!`, 'success');
                stopOsaekomi();
                return;
            }

        } else if (duree === seuils.yuko) {
            const yukoActuel = combatSimule[`${cote}_yuko`] || 0;
            combatSimule[`${cote}_yuko`] = yukoActuel + 1;
            combatSimule[cote].yuko = yukoActuel + 1;
            showNotification(`OSAEKOMI: +1 YUKO!`, 'success');
        }

        // Afficher simulation
        const vraiCombat = combat;
        combat = combatSimule;
        updateScoreDisplay();

        setTimeout(() => {
            combat = vraiCombat;
            updateScoreDisplay();
        }, 300);
    }

    // =======================================
    // FONCTIONS DE CORRECTION
    // =======================================

    function showCorrectionModal(cote) {
        if (!combat) return;

        correctionCote = cote;
        const combattantNom = cote === 'rouge' ?
            combat.rouge.nom : combat.bleu.nom;

        document.getElementById('correctionCombattant').textContent = combattantNom;

        updateScoreActuelModal();
        updateCorrectionButtons();

        const modal = new bootstrap.Modal(document.getElementById('modalCorrection'));
        modal.show();
    }

    function updateScoreActuelModal() {
        if (!combat || !correctionCote) return;

        const scores = correctionCote === 'rouge' ? combat.rouge : combat.bleu;
        let scoreHtml = '';

        const ippon = scores?.ippon || (correctionCote === 'rouge' ? combat.ipponRouge : combat.ipponBleu);
        const wazari = scores?.wazari || (correctionCote === 'rouge' ? combat.wazariRouge : combat.wazariBleu) || 0;
        const yuko = scores?.yuko || (correctionCote === 'rouge' ? combat.yukoRouge : combat.yukoBleu) || 0;
        const shido = scores?.shido || (correctionCote === 'rouge' ? combat.penalitesRouge : combat.penalitesBleu) || 0;

        if (ippon) {
            scoreHtml += '<span class="badge bg-warning text-dark me-2">IPPON</span>';
        } else {
            if (wazari > 0) {
                scoreHtml += `<span class="badge bg-info me-2">${wazari} WAZARI</span>`;
            }
            if (yuko > 0) {
                scoreHtml += `<span class="badge bg-success me-2">${yuko} YUKO</span>`;
            }
        }

        if (shido > 0) {
            scoreHtml += `<span class="badge bg-secondary me-2">${shido} SHIDO</span>`;
        }

        if (!scoreHtml) {
            scoreHtml = '<span class="text-muted">Aucun score</span>';
        }

        document.getElementById('scoreActuel').innerHTML = scoreHtml;
    }

    function updateCorrectionButtons() {
        if (!combat || !correctionCote) return;

        const scores = correctionCote === 'rouge' ? combat.rouge : combat.bleu;

        const ippon = scores?.ippon || (correctionCote === 'rouge' ? combat.ipponRouge : combat.ipponBleu);
        const wazari = scores?.wazari || (correctionCote === 'rouge' ? combat.wazariRouge : combat.wazariBleu) || 0;
        const yuko = scores?.yuko || (correctionCote === 'rouge' ? combat.yukoRouge : combat.yukoBleu) || 0;
        const shido = scores?.shido || (correctionCote === 'rouge' ? combat.penalitesRouge : combat.penalitesBleu) || 0;

        document.getElementById('btnRetirerIppon').disabled = !ippon;
        document.getElementById('btnRetirerWazari').disabled = wazari <= 0;
        document.getElementById('btnRetirerYuko').disabled = yuko <= 0;
        document.getElementById('btnRetirerShido').disabled = shido <= 0;

        document.getElementById('btnConvertIpponWazari').disabled = !ippon;
        document.getElementById('btnConvertIpponYuko').disabled = !ippon;
        document.getElementById('btnConvertWazariYuko').disabled = wazari <= 0;
    }

    async function retirerPoint(type) {
        if (!combat || !correctionCote || combat.etat === 'termin√©') return;

        try {
            const response = await fetch(`/api/combats/${combat.id}`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    action: 'correction',
                    cote: correctionCote,
                    operation: 'retirer',
                    type: type
                })
            });

            if (response.ok) {
                const updatedCombat = await response.json();
                combat = updatedCombat;

                updateScoreDisplay();
                updateScoreActuelModal();
                updateCorrectionButtons();

                animateScoreChange(correctionCote);

                showNotification(`${type.toUpperCase()} retir√©`, 'warning');
            } else {
                const error = await response.json();
                showNotification(error.error || 'Erreur de correction', 'danger');
            }
        } catch (error) {
            showNotification('Erreur de connexion', 'danger');
        }
    }

    async function convertirScore(conversion) {
        if (!combat || !correctionCote || combat.etat === 'termin√©') return;

        try {
            const [from, to] = conversion.split('-');

            const response = await fetch(`/api/combats/${combat.id}`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    action: 'correction',
                    cote: correctionCote,
                    operation: 'convertir',
                    from: from,
                    to: to
                })
            });

            if (response.ok) {
                const updatedCombat = await response.json();
                combat = updatedCombat;

                updateScoreDisplay();
                updateScoreActuelModal();
                updateCorrectionButtons();

                animateScoreChange(correctionCote);

                showNotification(`${from.toUpperCase()} converti en ${to.toUpperCase()}`, 'warning');
            } else {
                const error = await response.json();
                showNotification(error.error || 'Erreur de conversion', 'danger');
            }
        } catch (error) {
            showNotification('Erreur de connexion', 'danger');
        }
    }

    async function razScore() {
        if (!combat || !correctionCote) return;

        const combattantNom = correctionCote === 'rouge' ? combat.rouge.nom : combat.bleu.nom;
        const confirmation = confirm(
            `√ätes-vous s√ªr de vouloir remettre √† z√©ro tous les scores de ${combattantNom} ?`
        );
        if (!confirmation) return;

        try {
            const response = await fetch(`/api/combats/${combat.id}`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    action: 'correction',
                    cote: correctionCote,
                    operation: 'raz'
                })
            });

            if (response.ok) {
                const updatedCombat = await response.json();
                combat = updatedCombat;

                updateScoreDisplay();
                updateScoreActuelModal();
                updateCorrectionButtons();

                animateScoreChange(correctionCote);

                showNotification('Scores remis √† z√©ro', 'warning');
            } else {
                const error = await response.json();
                showNotification(error.error || 'Erreur de RAZ', 'danger');
            }
        } catch (error) {
            showNotification('Erreur de connexion', 'danger');
        }
    }

    // =======================================
    // TIMER ET UTILITAIRES
    // =======================================

    function startTimerDisplay() {
        stopTimerDisplay();

        timerInterval = setInterval(() => {
            if (timer > 0) {
                timer--;
                updateTimerDisplay();
                const syncInterval = CONFIG?.combat?.timerSyncInterval || 10;
                if (timer % syncInterval === 0) {
                    syncTimerWithBackend();
                }
            } else {
                stopTimerDisplay();
                finirCombatTemps();
            }
        }, 1000);
    }

    function stopTimerDisplay() {
        if (timerInterval) {
            clearInterval(timerInterval);
            timerInterval = null;
        }
    }

    async function syncTimerWithBackend() {
        if (!combat || combat.etat === 'termin√©') return;

        try {
            const response = await fetch(`/api/combats/${combat.id}`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    temps_ecoule: timer
                })
            });
            if (!response.ok) {
                const error = await response.json();
                console.warn('‚ö†Ô∏è Erreur sync timer (non-bloquante):', error);
            }
        } catch (error) {
            console.error('Erreur sync timer:', error);
        }
    }

    async function finirCombatTemps() {
        if (!combat) return;

        stopTimerDisplay();
        timer = 0;
        updateTimerDisplay();

        try {
            const response = await fetch(`/api/combats/${combat.id}`, {
                method: 'PATCH',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    etat: 'termin√©',
                    temps_ecoule: 0,
                    date_fin: new Date().toISOString(),
                    raison_fin: 'temps_ecoule'
                })
            });

            if (response.ok) {
                combat = await response.json();

                updateCombatDisplay();
                updateEtatCombat();
                showCombatTermine();

                setTimeout(() => {
                    reloadTatamiScore();
                }, 500);

                if (combat.vainqueur) {
                    const vainqueurNom = combat.vainqueur === 'rouge' ?
                        combat.rouge.nom : combat.bleu.nom;
                    showVictory(vainqueurNom, 'temps_ecoule');
                }

                showNotification('Temps √©coul√© - Combat termin√©', 'warning');
            }
        } catch (error) {
            showNotification('Erreur', 'danger');
        }
    }

    // =======================================
    // MISE √Ä JOUR DE LA FILE D'ATTENTE
    // =======================================

    async function updateQueue() {
        if (!tatami || !tatami.combatsIds || tatami.combatsIds.length <= 1) {
            document.getElementById('queueSection').style.display = 'none';
            return;
        }

        document.getElementById('queueSection').style.display = 'block';

        try {
            const response = await fetch(`/api/tatamis/${tatamiId}/historique-combats`);

            if (response.ok) {
                const historique = await response.json();
                const currentIndex = tatami.indexCombatActuel || 0;
                let queueHtml = '';

                const visibleRange = historique.slice(currentIndex, currentIndex + 4);

                visibleRange.forEach((combatInfo, idx) => {
                    const isCurrent = idx === 0;
                    const statusIcon = isCurrent ?
                        '<i class="fas fa-play-circle text-primary me-1"></i>' :
                        '<i class="fas fa-clock text-muted me-1"></i>';

                    queueHtml += `
                    <div class="queue-item ${isCurrent ? 'current' : ''}">
                        <div class="d-flex justify-content-between align-items-center">
                            <span>
                                ${statusIcon}
                                <strong>${combatInfo.rouge.nom}</strong> vs
                                <strong>${combatInfo.bleu.nom}</strong>
                            </span>
                            <small class="text-muted">#${combatInfo.index}</small>
                        </div>
                        <div class="small text-muted">
                            ${combatInfo.rouge.equipe} vs ${combatInfo.bleu.equipe}
                        </div>
                    </div>
                `;
                });

                if (!queueHtml) {
                    queueHtml = '<div class="queue-item"><span class="text-muted">Aucun combat suivant</span></div>';
                }

                document.getElementById('combatQueue').innerHTML = queueHtml;
            }
        } catch (error) {
            console.error('Erreur chargement file:', error);
            document.getElementById('combatQueue').innerHTML =
                '<div class="queue-item"><span class="text-muted">Erreur de chargement</span></div>';
        }
    }

    // =======================================
    // SSE
    // =======================================



    // =======================================
    // FONCTIONS D'AFFICHAGE
    // =======================================

    function showCombatTermine() {
        document.getElementById('btnNext').style.display = 'block';
        stopTimerDisplay();
        cleanupOsaekomoDisplay();
        reloadTatamiScore();
    }

    function showVictory(vainqueur, raison) {
        const raisonTexte = {
            'ippon': 'Par IPPON',
            'double_wazari': 'Par double WAZARI',
            'disqualification': 'Par disqualification',
            'temps_ecoule': 'Aux points',
            'arret_manuel': 'Combat arr√™t√©',
            'osaekomi_ippon': 'Par IPPON (Osaekomi)'
        };

        document.getElementById('victoryWinner').textContent = `${vainqueur} GAGNE!`;
        document.getElementById('victoryMethod').textContent = raisonTexte[raison] || raison;
        document.getElementById('victoryOverlay').style.display = 'flex';

        document.getElementById('btnNext').style.display = 'block';
    }

    function hideVictory() {
        document.getElementById('victoryOverlay').style.display = 'none';
    }

    // =======================================
    // POPUP FIN DE RENCONTRE
    // =======================================

    /**
     * Afficher le popup de fin de rencontre
     */
    function showFinRencontrePopup() {
        if (!tatami) return;

        // Mettre √† jour le score final
        const score = tatami.scoreConfrontation || { rouge: 0, bleu: 0 };
        document.getElementById('scoreFinalDisplay').textContent =
            `${score.rouge} - ${score.bleu}`;

        // Afficher le popup
        document.getElementById('finRencontreOverlay').classList.add('show');

        // Cacher le bouton "Combat Suivant"
        document.getElementById('btnNext').style.display = 'none';
    }

    /**
     * Cacher le popup de fin de rencontre
     */
    function hideFinRencontre() {
        document.getElementById('finRencontreOverlay').classList.remove('show');
    }

    /**
     * Retourner √† la gestion des tatamis
     */
    function retourGestionTatamis() {
        window.location.href = 'gestion_tatamis.html';
    }

    // =======================================
    // FONCTIONS UTILITAIRES
    // =======================================

    function animateScoreChange(cote) {
        const scoreElement = cote === 'rouge' ?
            document.getElementById('rougeScores') :
            document.getElementById('bleuScores');

        scoreElement.classList.add('score-change-animation');
        setTimeout(() => {
            scoreElement.classList.remove('score-change-animation');
        }, 500);
    }

    function updateConnectionStatus(text, type) {
        const indicator = document.getElementById('statusIndicator');
        indicator.className = `badge bg-${type} me-3`;
        indicator.innerHTML = `<i class="fas fa-circle me-1"></i>${text}`;
    }

    function showLoading(show) {
        document.getElementById('loadingOverlay').style.display = show ? 'flex' : 'none';
    }

    function showNotification(message, type = 'info') {
        const toast = document.createElement('div');
        toast.className = `alert alert-${type} alert-dismissible fade show position-fixed`;
        toast.style.cssText = 'top: 20px; right: 20px; z-index: 2000; min-width: 300px;';
        toast.innerHTML = `
        ${message}
        <button type="button" class="btn-close" onclick="this.parentElement.remove()"></button>
    `;

        document.body.appendChild(toast);

        setTimeout(() => {
            if (toast.parentElement) {
                toast.remove();
            }
        }, CONFIG?.display?.notificationDuration || 3000);
    }

    // =======================================
    // GESTION DES √âV√âNEMENTS
    // =======================================

    function setupEventListeners() {
        // Contr√¥les principaux
        document.getElementById('btnStart').addEventListener('click', startCombat);
        document.getElementById('btnPause').addEventListener('click', pauseCombat);
        document.getElementById('btnStop').addEventListener('click', stopCombat);
        document.getElementById('btnReset').addEventListener('click', resetCombat);
        document.getElementById('btnNext').addEventListener('click', combatSuivant);

        // Raccourcis clavier
        document.addEventListener('keydown', handleKeyboard);
    }

    // Gestion du clavier
    function handleKeyboard(e) {
        // Ignorer si on tape dans un input
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

        // Raccourcis de correction avec Ctrl
        if (e.ctrlKey) {
            switch (e.key.toLowerCase()) {
                case 'c':
                    e.preventDefault();
                    showCorrectionModal('rouge');
                    break;
                case 'v':
                    e.preventDefault();
                    showCorrectionModal('bleu');
                    break;
            }
            return;
        }

        switch (e.key.toLowerCase()) {
            case ' ': // Espace - Start/Pause
                e.preventDefault();
                if (!combat) return;
                if (combat.etat === 'en cours') {
                    pauseCombat();
                } else {
                    startCombat();
                }
                break;
            case 'r': // Reset
                e.preventDefault();
                resetCombat();
                break;
            case 'n': // Next
                e.preventDefault();
                if (combat && combat.etat === 'termin√©') {
                    combatSuivant();
                }
                break;
            // Scores rouge (touches num√©riques)
            case 'a':
                marquerPoint('rouge', 'ippon');
                break;
            case 's':
                marquerPoint('rouge', 'wazari');
                break;
            case 'w':
                marquerPoint('rouge', 'yuko');
                break;
            case 'e':
                marquerPoint('rouge', 'shido');
                break;
            // Scores bleu
            case 'p':
                marquerPoint('bleu', 'ippon');
                break;
            case 'l':
                marquerPoint('bleu', 'wazari');
                break;
            case 'k':
                marquerPoint('bleu', 'yuko');
                break;
            case 'i':
                marquerPoint('bleu', 'shido');
                break;
            // Osaekomi
            case '1':
                startOsaekomi('rouge');
                break;
            case '2':
                startOsaekomi('bleu');
                break;
            case '3':
                stopOsaekomi();
                break;
            case 'escape': // √âchap pour fermer les modals
                const openModals = document.querySelectorAll('.modal.show');
                openModals.forEach(modal => {
                    const modalInstance = bootstrap.Modal.getInstance(modal);
                    if (modalInstance) modalInstance.hide();
                });
                break;
            case 't': // T = Timer
                e.preventDefault();
                showTimerEditModal();
                break;
        }
    }

    // =======================================
    // GESTION DU TIMER PERSONNALIS√â
    // =======================================

    /**
     * Ajuster le timer de +/- X secondes
     */
    function adjustTimer(seconds) {
        if (!combat) return;

        // Emp√™cher les ajustements en combat termin√©
        if (combat.etat === 'termin√©') {
            showNotification('Impossible de modifier le timer sur un combat termin√©', 'warning');
            return;
        }

        timer = Math.max(0, timer + seconds);
        updateTimerDisplay();

        // Synchroniser avec le backend
        syncTimerWithBackend();

        const action = seconds > 0 ? 'ajout√©' : 'retir√©';
        showNotification(`${Math.abs(seconds)}s ${action}`, 'info');
    }

    /**
     * Afficher le modal de modification du timer
     */
    function showTimerEditModal() {
        if (!combat) return;

        if (combat.etat === 'termin√©') {
            showNotification('Impossible de modifier le timer sur un combat termin√©', 'warning');
            return;
        }

        // Pr√©-remplir avec le timer actuel
        const minutes = Math.floor(timer / 60);
        const seconds = timer % 60;

        document.getElementById('timerMinutes').value = minutes;
        document.getElementById('timerSeconds').value = seconds;

        const modal = new bootstrap.Modal(document.getElementById('modalTimer'));
        modal.show();
    }

    /**
     * Appliquer une dur√©e pr√©d√©finie
     */
    function setTimerPreset(seconds) {
        if (!combat) return;

        timer = seconds;
        updateTimerDisplay();

        // Synchroniser avec le backend
        syncTimerWithBackend();

        // Fermer le modal
        const modal = bootstrap.Modal.getInstance(document.getElementById('modalTimer'));
        if (modal) modal.hide();

        const minutes = Math.floor(seconds / 60);
        showNotification(`Timer d√©fini √† ${minutes}:00`, 'success');
    }

    /**
     * Appliquer un timer personnalis√©
     */
    function applyCustomTimer() {
        if (!combat) return;

        const minutes = parseInt(document.getElementById('timerMinutes').value) || 0;
        const seconds = parseInt(document.getElementById('timerSeconds').value) || 0;

        if (minutes < 0 || minutes > 10) {
            showNotification('Minutes invalides (0-10)', 'danger');
            return;
        }

        if (seconds < 0 || seconds > 59) {
            showNotification('Secondes invalides (0-59)', 'danger');
            return;
        }

        timer = (minutes * 60) + seconds;
        updateTimerDisplay();

        // Synchroniser avec le backend
        syncTimerWithBackend();

        // Fermer le modal
        const modal = bootstrap.Modal.getInstance(document.getElementById('modalTimer'));
        if (modal) modal.hide();

        showNotification(`Timer d√©fini √† ${minutes}:${seconds.toString().padStart(2, '0')}`, 'success');
    }

    /**
     * Mettre √† jour l'affichage des contr√¥les selon l'√©tat du combat
     */
    function updateTimerControlsVisibility() {
        const controls = document.getElementById('timerControls');
        if (!controls) return;

        // Cacher les contr√¥les si combat termin√©
        if (combat && combat.etat === 'termin√©') {
            controls.classList.add('hidden');
        } else {
            controls.classList.remove('hidden');
        }
    }

    // =======================================
    // RACCOURCIS GLOBAUX
    // =======================================

    // Exposer les fonctions principales pour les boutons HTML
    window.marquerPoint = marquerPoint;
    window.startOsaekomi = startOsaekomi;
    window.stopOsaekomi = stopOsaekomi;
    window.showCorrectionModal = showCorrectionModal;
    window.retirerPoint = retirerPoint;
    window.convertirScore = convertirScore;
    window.razScore = razScore;
    window.hideVictory = hideVictory;
    window.hideFinRencontre = hideFinRencontre;
    window.retourGestionTatamis = retourGestionTatamis;
</script>
</body>
</html>